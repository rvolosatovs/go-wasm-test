// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package sync represents the imported interface "dbg:app/sync".
package sync

import (
	"github.com/ydnar/wasm-tools-go/cm"
)

// Xx represents the imported resource "dbg:app/sync#xx".
//
//	resource xx
type Xx cm.Resource

// ResourceDrop represents the imported resource-drop for resource "xx".
//
// Drops a resource handle.
//
//go:nosplit
func (self Xx) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_XxResourceDrop((uint32)(self0))
	return
}

//go:wasmimport dbg:app/sync [resource-drop]xx
//go:noescape
func wasmimport_XxResourceDrop(self0 uint32)

// Abc represents the flags "dbg:app/sync#abc".
//
//	flags abc {
//		a,
//		b,
//		c,
//	}
type Abc uint8

const (
	AbcA Abc = 1 << iota
	AbcB
	AbcC
)

// RecNested represents the record "dbg:app/sync#rec-nested".
//
//	record rec-nested {
//		foo: string,
//	}
type RecNested struct {
	Foo string
}

// Rec represents the record "dbg:app/sync#rec".
//
//	record rec {
//		nested: rec-nested,
//	}
type Rec struct {
	Nested RecNested
}

// Var represents the variant "dbg:app/sync#var".
//
//	variant var {
//		var(rec),
//		empty,
//	}
type Var cm.Variant[uint8, Rec, Rec]

// VarVar returns a [Var] of case "var".
func VarVar(data Rec) Var {
	return cm.New[Var](0, data)
}

// Var returns a non-nil *[Rec] if [Var] represents the variant case "var".
func (self *Var) Var() *Rec {
	return cm.Case[Rec](self, 0)
}

// VarEmpty returns a [Var] of case "empty".
func VarEmpty() Var {
	var data struct{}
	return cm.New[Var](1, data)
}

// Empty returns true if [Var] represents the variant case "empty".
func (self *Var) Empty() bool {
	return self.Tag() == 1
}

// Foobar represents the enum "dbg:app/sync#foobar".
//
//	enum foobar {
//		foo,
//		bar
//	}
type Foobar uint8

const (
	FoobarFoo Foobar = iota
	FoobarBar
)

var stringsFoobar = [2]string{
	"foo",
	"bar",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e Foobar) String() string {
	return stringsFoobar[e]
}

// Fallible represents the imported function "fallible".
//
//	fallible: func(ok: bool) -> result<bool, string>
//
//go:nosplit
func Fallible(ok bool) (result cm.Result[string, bool, string]) {
	ok0 := cm.BoolToU32(ok)
	wasmimport_Fallible((uint32)(ok0), &result)
	return
}

//go:wasmimport dbg:app/sync fallible
//go:noescape
func wasmimport_Fallible(ok0 uint32, result *cm.Result[string, bool, string])

// Numbers represents the imported function "numbers".
//
//	numbers: func(a: u8, b: u16, c: u32, d: u64, e: s8, f: s16, g: s32, x: s64, aa:
//	f32, bb: f64) -> tuple<u8, u16, u32, u64, s8, s16, s32, s64, f32, f64>
//
//go:nosplit
func Numbers(a uint8, b uint16, c uint32, d uint64, e int8, f int16, g int32, x int64, aa float32, bb float64) (result cm.Tuple10[uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64]) {
	a0 := (uint32)(a)
	b0 := (uint32)(b)
	c0 := (uint32)(c)
	d0 := (uint64)(d)
	e0 := (uint32)(e)
	f0 := (uint32)(f)
	g0 := (uint32)(g)
	x0 := (uint64)(x)
	aa0 := (float32)(aa)
	bb0 := (float64)(bb)
	wasmimport_Numbers((uint32)(a0), (uint32)(b0), (uint32)(c0), (uint64)(d0), (uint32)(e0), (uint32)(f0), (uint32)(g0), (uint64)(x0), (float32)(aa0), (float64)(bb0), &result)
	return
}

//go:wasmimport dbg:app/sync numbers
//go:noescape
func wasmimport_Numbers(a0 uint32, b0 uint32, c0 uint32, d0 uint64, e0 uint32, f0 uint32, g0 uint32, x0 uint64, aa0 float32, bb0 float64, result *cm.Tuple10[uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64])

// WithFlags represents the imported function "with-flags".
//
//	with-flags: func(a: bool, b: bool, c: bool) -> abc
//
//go:nosplit
func WithFlags(a bool, b bool, c bool) (result Abc) {
	a0 := cm.BoolToU32(a)
	b0 := cm.BoolToU32(b)
	c0 := cm.BoolToU32(c)
	result0 := wasmimport_WithFlags((uint32)(a0), (uint32)(b0), (uint32)(c0))
	result = (Abc)((uint32)(result0))
	return
}

//go:wasmimport dbg:app/sync with-flags
//go:noescape
func wasmimport_WithFlags(a0 uint32, b0 uint32, c0 uint32) (result0 uint32)

// WithVariantOption represents the imported function "with-variant-option".
//
//	with-variant-option: func(ok: bool) -> option<var>
//
//go:nosplit
func WithVariantOption(ok bool) (result cm.Option[Var]) {
	ok0 := cm.BoolToU32(ok)
	wasmimport_WithVariantOption((uint32)(ok0), &result)
	return
}

//go:wasmimport dbg:app/sync with-variant-option
//go:noescape
func wasmimport_WithVariantOption(ok0 uint32, result *cm.Option[Var])

// WithVariantList represents the imported function "with-variant-list".
//
//	with-variant-list: func(c: char, s: string, l: list<u8>, l2: list<rec>, l3: list<u64>,
//	o: xx, bo: borrow<xx>) -> (first: list<var>, second: xx)
//
//go:nosplit
func WithVariantList(c rune, s string, l cm.List[uint8], l2 cm.List[Rec], l3 cm.List[uint64], o Xx, bo Xx) (first cm.List[Var], second Xx) {
	c0 := (uint32)(c)
	s0, s1 := cm.LowerString(s)
	l0, l1 := cm.LowerList(l)
	l20, l21 := cm.LowerList(l2)
	l30, l31 := cm.LowerList(l3)
	o0 := cm.Reinterpret[uint32](o)
	bo0 := cm.Reinterpret[uint32](bo)
	var results wasmimport_WithVariantList_results
	wasmimport_WithVariantList((uint32)(c0), (*uint8)(s0), (uint32)(s1), (*uint8)(l0), (uint32)(l1), (*Rec)(l20), (uint32)(l21), (*uint64)(l30), (uint32)(l31), (uint32)(o0), (uint32)(bo0), &results)
	return results.first, results.second
}

//go:wasmimport dbg:app/sync with-variant-list
//go:noescape
func wasmimport_WithVariantList(c0 uint32, s0 *uint8, s1 uint32, l0 *uint8, l1 uint32, l20 *Rec, l21 uint32, l30 *uint64, l31 uint32, o0 uint32, bo0 uint32, results *wasmimport_WithVariantList_results)

// wasmimport_WithVariantList_results represents the flattened function results for [wasmimport_WithVariantList].
// See the Canonical ABI flattening rules for more information.
type wasmimport_WithVariantList_results struct {
	first  cm.List[Var]
	second Xx
}

// WithRecord represents the imported function "with-record".
//
//	with-record: func(r: rec) -> rec
//
//go:nosplit
func WithRecord(r Rec) (result Rec) {
	r0, r1 := lower_Rec(r)
	wasmimport_WithRecord((*uint8)(r0), (uint32)(r1), &result)
	return
}

//go:wasmimport dbg:app/sync with-record
//go:noescape
func wasmimport_WithRecord(r0 *uint8, r1 uint32, result *Rec)

// WithRecordList represents the imported function "with-record-list".
//
//	with-record-list: func(n: u8) -> list<rec>
//
//go:nosplit
func WithRecordList(n uint8) (result cm.List[Rec]) {
	n0 := (uint32)(n)
	wasmimport_WithRecordList((uint32)(n0), &result)
	return
}

//go:wasmimport dbg:app/sync with-record-list
//go:noescape
func wasmimport_WithRecordList(n0 uint32, result *cm.List[Rec])

// WithRecordTuple represents the imported function "with-record-tuple".
//
//	with-record-tuple: func(x: tuple<u8, u8>) -> tuple<rec, rec>
//
//go:nosplit
func WithRecordTuple(x [2]uint8) (result [2]Rec) {
	x0, x1 := lower_TupleU8U8(x)
	wasmimport_WithRecordTuple((uint32)(x0), (uint32)(x1), &result)
	return
}

//go:wasmimport dbg:app/sync with-record-tuple
//go:noescape
func wasmimport_WithRecordTuple(x0 uint32, x1 uint32, result *[2]Rec)

// WithEnum represents the imported function "with-enum".
//
//	with-enum: func() -> foobar
//
//go:nosplit
func WithEnum() (result Foobar) {
	result0 := wasmimport_WithEnum()
	result = (Foobar)((uint32)(result0))
	return
}

//go:wasmimport dbg:app/sync with-enum
//go:noescape
func wasmimport_WithEnum() (result0 uint32)
